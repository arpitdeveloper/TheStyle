/// <reference types="lodash" />
import * as App from '@flamelink/sdk-app-types';
export declare const getDefaultImport: (mod: any) => any;
export declare function logError(str: string): void;
export declare function logWarning(str: string): void;
export declare const wrap: import("lodash").CurriedFunction2<string, any, {
    [x: string]: any;
}>;
export declare const unwrap: import("lodash").CurriedFunction2<string, any, any>;
export declare class FlamelinkError extends Error {
    code: string;
    private showStackTrace;
    constructor(message: string, code?: string, showStackTrace?: boolean);
}
export declare class EventEmitter implements App.EventEmitter.Emitter {
    private readonly events;
    on(event: string, listener: App.EventEmitter.Listener): () => void;
    off(event: string, listener: App.EventEmitter.Listener): void;
    offAll(): void;
    emit(event: string, ...args: any[]): void;
    once(event: string, listener: App.EventEmitter.Listener): () => void;
}
export declare class PromiseEmitter extends EventEmitter {
    private callback;
    private state;
    private internalValue;
    private readonly chain;
    constructor(callback: App.PromiseEmitter.Callback);
    then(onFulfilled: App.PromiseEmitter.ResolveFn, onRejected?: App.PromiseEmitter.RejectFn): Promise<any>;
    catch(onRejected?: App.PromiseEmitter.RejectFn): Promise<any>;
}
export declare const getStorageServiceFactory: (context: App.Context) => any;
export declare const getFirestoreServiceFactory: (context: App.Context) => any;
export declare const getAuthServiceFactory: (context: App.Context) => any;
export declare const getTimestamp: (context: App.Context) => any;
export declare const getCurrentUser: (context: App.Context) => any;
export declare const AVAILABLE_FILTER_OPTIONS_FOR_RTDB: string[];
export declare const CF_QUERY_CURSORS: string[];
export declare const hasNonCacheableOptionsForRTDB: (options: any) => any;
export declare const hasNonCacheableOptionsForCF: (options: any) => any;
export declare const applyOrderByForRTDB: (ref: any, options: App.RTDB.OrderByOptions) => any;
export declare const applyFiltersForRTDB: (ref: any, options?: App.RTDB.FilterOptions) => any;
export declare const applyOptionsForRTDB: (ref: any, options: App.RTDB.Options) => any;
export declare const applyOrderByForCF: (ref: any, options: any) => any;
export declare const applyFiltersForCF: (ref: any, options: App.CF.FilterOptions) => any;
export declare const applyLimitAndOffsetsForCF: (ref: any, options: App.CF.LimitOptions) => any;
export declare const pluckResultFields: import("lodash").CurriedFunction2<any, any, any>;
export declare const isRefLike: (value: any) => boolean;
interface StructureOptions {
    idProperty?: string;
    parentProperty?: string;
}
export declare const formatStructure: import("lodash").CurriedFunction3<string, StructureOptions, any, any[]>;
export declare const applyOptionsForCF: (ref: any, options: App.CF.Options) => any;
interface PopulateFieldOption {
    field: string;
    [key: string]: any;
}
export declare const prepPopulateFields: (populate?: string[] | PopulateFieldOption | PopulateFieldOption[]) => PopulateFieldOption[];
export declare const patchFileUrlForCF: import("lodash").CurriedFunction3<App.Context, App.CF.Options, any, Promise<any>>;
export declare const processReferencesForCF: import("lodash").CurriedFunction3<App.Context, App.CF.Options, any, Promise<any>>;
export declare const populateEntriesForCF: import("lodash").CurriedFunction3<App.Context, App.CF.Options, any, Promise<any>>;
export declare const createQueue: import("lodash").CurriedFunction2<any, any[], {
    start: () => any;
}>;
export declare const populateEntry: import("lodash").CurriedFunction4<App.Context, string, any, any, Promise<any>>;
export declare const populateEntries: import("lodash").CurriedFunction4<App.Context, string, any, any[], Promise<any[]>>;
export {};
